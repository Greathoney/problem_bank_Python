# 스마트폰 패턴 잠금 경우의 수를 잘 따져보자.
문제가 다소 까다로울 수 있으니 천천히 풀어봅시다.
그래도 조건들은 문제의 규칙에서 모두 주어져 있으므로 어렵진 않게 풀 수 있을 겁니다.

### 문제풀어가는 흐름!
1~4의 조건을 만족하는 조건에다가 5~6조건을 만족하는것을 제외하면 답을 구할 수 있다고 봅니다.

### 1~4 번의 조건은 어떻게 될까?
(첫번째 점, 두번째 점, 세번째 점, 네번째 점)
(첫번째 점, 두번째 점, 세번째 점, 네번째 점, 다섯번째 점)...
…(첫번째 점, 두번째 점, … , 아홉번째 점)
이렇게 6개의 경우로 나누어 생각해보고 조건 5,6 을 제외한 경우의 수는 9P4+9P5+9P6+9P7+9P8+9P9=985824 가지이다. 이때 순열은 (1,2,3,4) (1,2,3,5) (1,2,3,6) (1,2,3,7) … (9,8,7,6,5,4,3,2,1) 이렇게 총 985824가지가 구성된다.
```python
총경우의수=[]
for 집합의길이 in range (4,10):
    for 일점 in range (1,10):
        for 이점 in range (1,10):
            if 일점 != 이점:
                for 삼점 in range (1,10):
                    if 일점 != 삼점 and 이점 != 삼점:
                        for 사점 in range (1,10):
                            if 일점 != 사점 and 이점 != 사점 and 삼점 != 사점:
                                if 집합의길이==4:
                                    총경우의수.append([일점,이점,삼점,사점])
                                else:
                                    for 오점 in range (1,10):
                                        if 일점 != 오점 and 이점 != 오점 and 삼점 != 오점 and 사점 != 오점:
                                            if 집합의길이==5:
                                                총경우의수.append([일점,이점,삼점,사점,오점])
                                            else:
                                                for 육점 in range (1,10):
                                                    if 일점 != 육점 and 이점 != 육점 and 삼점 != 육점 and 사점 != 육점 and 오점 != 육점:
                                                        if 집합의길이==6:
                                                            총경우의수.append([일점,이점,삼점,사점,오점,육점])
                                                        else:
                                                            for 칠점 in range(1,10):
                                                                if 일점 !=칠점 and 이점 !=칠점 and 삼점 !=칠점 and 사점 !=칠점 and 오점 !=칠점 and 육점 !=칠점:
                                                                    if 집합의길이==7:
                                                                        총경우의수.append([일점,이점,삼점,사점,오점,육점,칠점])
                                                                    else:
                                                                        for 팔점 in range(1,10):
                                                                            if 일점 !=팔점 and 이점 !=팔점 and 삼점 !=팔점 and 사점 !=팔점 and 오점 !=팔점 and 육점 !=팔점 and 칠점 !=팔점:
                                                                                if 집합의길이==8:
                                                                                    총경우의수.append([일점,이점,삼점,사점,오점,육점,칠점,팔점])
                                                                                else:
                                                                                    for 구점 in range(1,10):
                                                                                        if 일점 !=구점 and 이점 !=구점 and 삼점 !=구점 and 사점 !=구점 and 오점 !=구점 and 육점 !=구점 and 칠점 !=구점 and 팔점 !=구점:
                                                                                            총경우의수.append([일점,이점,삼점,사점,오점,육점,칠점,팔점,구점])

```
다소 난잡해 보이지만 결론은 규칙성있게 가져오는 것 뿐이다.

### 5~6 번의 조건은 어떻게 될까?
여기까지만 보면 조건 5,6 을 만족시키지 못하기 때문에 조건 5,6 을 만족하는 부분을 설계했다.

이 경우를 만족하지 않으려면 1->3 2->8같은 건너뛰기 수가 없어야하는데 이러한 경우는 (<모서리수> 1-3, 1-7, 1-9, 3-1, 3-7, 3-9, 7-1, 7-3, 7-9, 9-1, 9-3, 9-7 // <가운데 수> 2-8, 4-6, 6-4, 8-2 )로 모두 16가지 경우가 있었다. 하지만 중간에 위치한 수가 위 경우들 앞에 배치되어 있다면 조건을 만족하게 되므로 우리가 생각한 여집합을 걸러내는 방법은 다음과 같다.
[1,2,3,4], [1,2,3,5] ~[9,8,7,6,5,4,3,2,1] 까지 모든 경우의 비밀번호를 생성하고
1-3,2-8 등의 건너뛰기 수가 있는 수들에 대해서는
앞에 사잇수가 있는지 확인하여 있다면 남겨두고 없다면 전체 경우의수에서 빼버린다.   

이것을 모두 종합적으로 고려해 만든 파이썬의 코딩은 다음과 같다.


with Mr.Park :)
